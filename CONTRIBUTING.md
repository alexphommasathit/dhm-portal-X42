# Contribution Guidelines

## 1. Code Style & Formatting
* **Prettier**: Add an explicit .prettierrc file with your team's preferred settings (semicolons, quote style, trailing commas, etc.). Enforce formatOnSave.
* **ESLint**: Continue enforcing ESLint rules strictly.
* **Naming Conventions**: Define clear conventions for variables, functions, components, files (e.g., camelCase for variables/functions, PascalCase for components).

## 2. TypeScript Usage
* **Strict Types**: Leverage TypeScript's strengths. Avoid `any` wherever possible. Define clear interfaces and types.
* **Type Safety**: Utilize Supabase's type generation for database interactions.

## 3. Security Practices (Reinforce & Expand)
* **RBAC Everywhere**: Explicitly check roles/permissions in API routes/Edge Functions and conditionally render UI components using the established RBAC context/HOC. Never trust client-side checks alone.
* **Input Validation**: Validate all inputs received from the client (API route bodies, function arguments) using libraries like Zod.
* **Supabase RLS**: Rely on Row Level Security as the ultimate gatekeeper. Ensure policies are comprehensive and tested. Code should assume RLS is active.
* **Audit Logging**: Log all significant actions involving PHI or critical system changes, following the established system. Be mindful not to log excessively sensitive data (like full PHI details) in the logs themselves if avoidable.
* **Error Handling**: Implement robust error handling; don't expose sensitive system details in error messages sent to the client.
* **Secrets Management**: Use environment variables (.env.local, Vercel env vars) for API keys, Supabase keys, etc. Never hardcode secrets.

## 4. Component & Architecture
* **Adhere to Structure**: Follow the established project structure (App Router conventions, components, context, lib).
* **Reusability**: Build reusable components (especially UI elements using ShadCN UI) where appropriate.
* **State Management**: Use Context API for global state (like RBAC) and useState/useReducer for local component state unless more complex needs arise.

## 5. API Usage (Supabase & AI)
* **Supabase Client**: Use the shared Supabase client instances.
* **Data Fetching**: Select only the data needed (select('column1, column2')) to minimize data transfer.
* **AI APIs**: Ensure all interactions with AI APIs (Embeddings, Chat) happen server-side (Edge Functions/API routes). Adhere strictly to BAA terms. Handle potential API errors gracefully.

## 6. AI Tool Usage (Cursor Rules)
* **Review Mandate**: All AI-generated code must be reviewed and understood before committing.
* **No Sensitive Data in Prompts**: Use placeholders or abstract descriptions, never real PHI.
* **Context is Key**: Provide clear context for better suggestions.
* **Security Focus**: Explicitly ask for secure coding patterns when relevant. Verify AI suggestions meet security requirements (RBAC, validation, RLS awareness).
* **Test AI Output**: Write tests for logic generated by AI.
* **Leverage Strengths**: Use for boilerplate, refactoring, docs, tests, but be critical of complex logic.

## 7. Testing
* **Strategy**: Define a basic testing strategy (e.g., Vitest/Jest + React Testing Library).
* **Priorities**: Prioritize testing critical functions: Auth logic, RBAC checks, API endpoints, security-sensitive utility functions, core business logic (like P&P interactions later).

## 8. Documentation
* **Code Comments**: Use JSDoc/TSDoc for functions, complex logic, and component props.
* **README**: Keep the README updated with setup instructions, core features, and links to further documentation (like the Development Guidelines).

## 9. Git Workflow
* **Branching**: Use a consistent branching strategy (e.g., Gitflow - main, develop, feature/xxx).
* **Commits**: Write clear, descriptive commit messages.

   

   

